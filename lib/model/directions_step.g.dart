// GENERATED CODE - DO NOT MODIFY BY HAND


part of 'directions_step.dart';

// **************************************************************************
// BuiltValueGenerator
// **************************************************************************

const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_turnSlightLeft =
    const DirectionsStepManeuverEnum._('turnSlightLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_turnSharpLeft =
    const DirectionsStepManeuverEnum._('turnSharpLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_turnLeft =
    const DirectionsStepManeuverEnum._('turnLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_turnSlightRight =
    const DirectionsStepManeuverEnum._('turnSlightRight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_turnSharpRight =
    const DirectionsStepManeuverEnum._('turnSharpRight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_keepRight =
    const DirectionsStepManeuverEnum._('keepRight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_keepLeft =
    const DirectionsStepManeuverEnum._('keepLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_uturnLeft =
    const DirectionsStepManeuverEnum._('uturnLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_uturnRight =
    const DirectionsStepManeuverEnum._('uturnRight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_turnRight =
    const DirectionsStepManeuverEnum._('turnRight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_straight =
    const DirectionsStepManeuverEnum._('straight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_rampLeft =
    const DirectionsStepManeuverEnum._('rampLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_rampRight =
    const DirectionsStepManeuverEnum._('rampRight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_merge =
    const DirectionsStepManeuverEnum._('merge');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_forkLeft =
    const DirectionsStepManeuverEnum._('forkLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_forkRight =
    const DirectionsStepManeuverEnum._('forkRight');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_ferry =
    const DirectionsStepManeuverEnum._('ferry');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_ferryTrain =
    const DirectionsStepManeuverEnum._('ferryTrain');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_roundaboutLeft =
    const DirectionsStepManeuverEnum._('roundaboutLeft');
const DirectionsStepManeuverEnum _$directionsStepManeuverEnum_roundaboutRight =
    const DirectionsStepManeuverEnum._('roundaboutRight');

DirectionsStepManeuverEnum _$directionsStepManeuverEnumValueOf(String name) {
  switch (name) {
    case 'turnSlightLeft':
      return _$directionsStepManeuverEnum_turnSlightLeft;
    case 'turnSharpLeft':
      return _$directionsStepManeuverEnum_turnSharpLeft;
    case 'turnLeft':
      return _$directionsStepManeuverEnum_turnLeft;
    case 'turnSlightRight':
      return _$directionsStepManeuverEnum_turnSlightRight;
    case 'turnSharpRight':
      return _$directionsStepManeuverEnum_turnSharpRight;
    case 'keepRight':
      return _$directionsStepManeuverEnum_keepRight;
    case 'keepLeft':
      return _$directionsStepManeuverEnum_keepLeft;
    case 'uturnLeft':
      return _$directionsStepManeuverEnum_uturnLeft;
    case 'uturnRight':
      return _$directionsStepManeuverEnum_uturnRight;
    case 'turnRight':
      return _$directionsStepManeuverEnum_turnRight;
    case 'straight':
      return _$directionsStepManeuverEnum_straight;
    case 'rampLeft':
      return _$directionsStepManeuverEnum_rampLeft;
    case 'rampRight':
      return _$directionsStepManeuverEnum_rampRight;
    case 'merge':
      return _$directionsStepManeuverEnum_merge;
    case 'forkLeft':
      return _$directionsStepManeuverEnum_forkLeft;
    case 'forkRight':
      return _$directionsStepManeuverEnum_forkRight;
    case 'ferry':
      return _$directionsStepManeuverEnum_ferry;
    case 'ferryTrain':
      return _$directionsStepManeuverEnum_ferryTrain;
    case 'roundaboutLeft':
      return _$directionsStepManeuverEnum_roundaboutLeft;
    case 'roundaboutRight':
      return _$directionsStepManeuverEnum_roundaboutRight;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<DirectionsStepManeuverEnum> _$directionsStepManeuverEnumValues =
    new BuiltSet<DirectionsStepManeuverEnum>(const <DirectionsStepManeuverEnum>[
  _$directionsStepManeuverEnum_turnSlightLeft,
  _$directionsStepManeuverEnum_turnSharpLeft,
  _$directionsStepManeuverEnum_turnLeft,
  _$directionsStepManeuverEnum_turnSlightRight,
  _$directionsStepManeuverEnum_turnSharpRight,
  _$directionsStepManeuverEnum_keepRight,
  _$directionsStepManeuverEnum_keepLeft,
  _$directionsStepManeuverEnum_uturnLeft,
  _$directionsStepManeuverEnum_uturnRight,
  _$directionsStepManeuverEnum_turnRight,
  _$directionsStepManeuverEnum_straight,
  _$directionsStepManeuverEnum_rampLeft,
  _$directionsStepManeuverEnum_rampRight,
  _$directionsStepManeuverEnum_merge,
  _$directionsStepManeuverEnum_forkLeft,
  _$directionsStepManeuverEnum_forkRight,
  _$directionsStepManeuverEnum_ferry,
  _$directionsStepManeuverEnum_ferryTrain,
  _$directionsStepManeuverEnum_roundaboutLeft,
  _$directionsStepManeuverEnum_roundaboutRight,
]);

Serializer<DirectionsStepManeuverEnum> _$directionsStepManeuverEnumSerializer =
    new _$DirectionsStepManeuverEnumSerializer();

class _$DirectionsStepManeuverEnumSerializer
    implements PrimitiveSerializer<DirectionsStepManeuverEnum> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'turnSlightLeft': 'turn-slight-left',
    'turnSharpLeft': 'turn-sharp-left',
    'turnLeft': 'turn-left',
    'turnSlightRight': 'turn-slight-right',
    'turnSharpRight': 'turn-sharp-right',
    'keepRight': 'keep-right',
    'keepLeft': 'keep-left',
    'uturnLeft': 'uturn-left',
    'uturnRight': 'uturn-right',
    'turnRight': 'turn-right',
    'straight': 'straight',
    'rampLeft': 'ramp-left',
    'rampRight': 'ramp-right',
    'merge': 'merge',
    'forkLeft': 'fork-left',
    'forkRight': 'fork-right',
    'ferry': 'ferry',
    'ferryTrain': 'ferry-train',
    'roundaboutLeft': 'roundabout-left',
    'roundaboutRight': 'roundabout-right',
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    'turn-slight-left': 'turnSlightLeft',
    'turn-sharp-left': 'turnSharpLeft',
    'turn-left': 'turnLeft',
    'turn-slight-right': 'turnSlightRight',
    'turn-sharp-right': 'turnSharpRight',
    'keep-right': 'keepRight',
    'keep-left': 'keepLeft',
    'uturn-left': 'uturnLeft',
    'uturn-right': 'uturnRight',
    'turn-right': 'turnRight',
    'straight': 'straight',
    'ramp-left': 'rampLeft',
    'ramp-right': 'rampRight',
    'merge': 'merge',
    'fork-left': 'forkLeft',
    'fork-right': 'forkRight',
    'ferry': 'ferry',
    'ferry-train': 'ferryTrain',
    'roundabout-left': 'roundaboutLeft',
    'roundabout-right': 'roundaboutRight',
  };

  @override
  final Iterable<Type> types = const <Type>[DirectionsStepManeuverEnum];
  @override
  final String wireName = 'DirectionsStepManeuverEnum';

  @override
  Object serialize(Serializers serializers, DirectionsStepManeuverEnum object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  DirectionsStepManeuverEnum deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      DirectionsStepManeuverEnum.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$DirectionsStep extends DirectionsStep {
  @override
  final TextValueObject? duration;
  @override
  final LatLngLiteral? endLocation;
  @override
  final String? htmlInstructions;
  @override
  final DirectionsPolyline? polyline;
  @override
  final LatLngLiteral? startLocation;
  @override
  final TravelMode? travelMode;
  @override
  final TextValueObject? distance;
  @override
  final DirectionsStepManeuverEnum? maneuver;
  @override
  final DirectionsTransitDetails? transitDetails;
  @override
  final JsonObject? steps;

  factory _$DirectionsStep([void Function(DirectionsStepBuilder)? updates]) =>
      (new DirectionsStepBuilder()..update(updates)).build();

  _$DirectionsStep._(
      {this.duration,
      this.endLocation,
      this.htmlInstructions,
      this.polyline,
      this.startLocation,
      this.travelMode,
      this.distance,
      this.maneuver,
      this.transitDetails,
      this.steps})
      : super._();

  @override
  DirectionsStep rebuild(void Function(DirectionsStepBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  DirectionsStepBuilder toBuilder() =>
      new DirectionsStepBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is DirectionsStep &&
        duration == other.duration &&
        endLocation == other.endLocation &&
        htmlInstructions == other.htmlInstructions &&
        polyline == other.polyline &&
        startLocation == other.startLocation &&
        travelMode == other.travelMode &&
        distance == other.distance &&
        maneuver == other.maneuver &&
        transitDetails == other.transitDetails &&
        steps == other.steps;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc(
                                $jc(
                                    $jc($jc(0, duration.hashCode),
                                        endLocation.hashCode),
                                    htmlInstructions.hashCode),
                                polyline.hashCode),
                            startLocation.hashCode),
                        travelMode.hashCode),
                    distance.hashCode),
                maneuver.hashCode),
            transitDetails.hashCode),
        steps.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('DirectionsStep')
          ..add('duration', duration)
          ..add('endLocation', endLocation)
          ..add('htmlInstructions', htmlInstructions)
          ..add('polyline', polyline)
          ..add('startLocation', startLocation)
          ..add('travelMode', travelMode)
          ..add('distance', distance)
          ..add('maneuver', maneuver)
          ..add('transitDetails', transitDetails)
          ..add('steps', steps))
        .toString();
  }
}

class DirectionsStepBuilder
    implements Builder<DirectionsStep, DirectionsStepBuilder> {
  _$DirectionsStep? _$v;

  TextValueObjectBuilder? _duration;
  TextValueObjectBuilder get duration =>
      _$this._duration ??= new TextValueObjectBuilder();
  set duration(TextValueObjectBuilder duration) => _$this._duration = duration;

  LatLngLiteralBuilder? _endLocation;
  LatLngLiteralBuilder get endLocation =>
      _$this._endLocation ??= new LatLngLiteralBuilder();
  set endLocation(LatLngLiteralBuilder endLocation) =>
      _$this._endLocation = endLocation;

  String? _htmlInstructions;
  String? get htmlInstructions => _$this._htmlInstructions;
  set htmlInstructions(String? htmlInstructions) =>
      _$this._htmlInstructions = htmlInstructions;

  DirectionsPolylineBuilder? _polyline;
  DirectionsPolylineBuilder get polyline =>
      _$this._polyline ??= new DirectionsPolylineBuilder();
  set polyline(DirectionsPolylineBuilder polyline) =>
      _$this._polyline = polyline;

  LatLngLiteralBuilder? _startLocation;
  LatLngLiteralBuilder get startLocation =>
      _$this._startLocation ??= new LatLngLiteralBuilder();
  set startLocation(LatLngLiteralBuilder startLocation) =>
      _$this._startLocation = startLocation;

  TravelMode? _travelMode;
  TravelMode? get travelMode => _$this._travelMode;
  set travelMode(TravelMode? travelMode) => _$this._travelMode = travelMode;

  TextValueObjectBuilder? _distance;
  TextValueObjectBuilder get distance =>
      _$this._distance ??= new TextValueObjectBuilder();
  set distance(TextValueObjectBuilder distance) => _$this._distance = distance;

  DirectionsStepManeuverEnum? _maneuver;
  DirectionsStepManeuverEnum? get maneuver => _$this._maneuver;
  set maneuver(DirectionsStepManeuverEnum? maneuver) =>
      _$this._maneuver = maneuver;

  DirectionsTransitDetailsBuilder? _transitDetails;
  DirectionsTransitDetailsBuilder get transitDetails =>
      _$this._transitDetails ??= new DirectionsTransitDetailsBuilder();
  set transitDetails(DirectionsTransitDetailsBuilder transitDetails) =>
      _$this._transitDetails = transitDetails;

  JsonObject? _steps;
  JsonObject? get steps => _$this._steps;
  set steps(JsonObject? steps) => _$this._steps = steps;

  DirectionsStepBuilder() {
    DirectionsStep._initializeBuilder(this);
  }

  DirectionsStepBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _duration = $v.duration?.toBuilder();
      _endLocation = $v.endLocation?.toBuilder();
      _htmlInstructions = $v.htmlInstructions;
      _polyline = $v.polyline?.toBuilder();
      _startLocation = $v.startLocation?.toBuilder();
      _travelMode = $v.travelMode;
      _distance = $v.distance?.toBuilder();
      _maneuver = $v.maneuver;
      _transitDetails = $v.transitDetails?.toBuilder();
      _steps = $v.steps;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(DirectionsStep other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$DirectionsStep;
  }

  @override
  void update(void Function(DirectionsStepBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$DirectionsStep build() {
    _$DirectionsStep _$result;
    try {
      _$result = _$v ??
          new _$DirectionsStep._(
              duration: _duration?.build(),
              endLocation: _endLocation?.build(),
              htmlInstructions: htmlInstructions,
              polyline: _polyline?.build(),
              startLocation: _startLocation?.build(),
              travelMode: travelMode,
              distance: _distance?.build(),
              maneuver: maneuver,
              transitDetails: _transitDetails?.build(),
              steps: steps);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'duration';
        _duration?.build();
        _$failedField = 'endLocation';
        _endLocation?.build();

        _$failedField = 'polyline';
        _polyline?.build();
        _$failedField = 'startLocation';
        _startLocation?.build();

        _$failedField = 'distance';
        _distance?.build();

        _$failedField = 'transitDetails';
        _transitDetails?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'DirectionsStep', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

// ignore_for_file: always_put_control_body_on_new_line,always_specify_types,annotate_overrides,avoid_annotating_with_dynamic,avoid_as,avoid_catches_without_on_clauses,avoid_returning_this,deprecated_member_use_from_same_package,lines_longer_than_80_chars,omit_local_variable_types,prefer_expression_function_bodies,sort_constructors_first,test_types_in_equals,unnecessary_const,unnecessary_new
